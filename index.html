<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iterated Prisoner's Dilemma Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            padding: 20px;
        }

        .controls-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            height: fit-content;
        }

        .control-section {
            margin-bottom: 24px;
        }

        .control-section h3 {
            font-size: 1.1em;
            margin-bottom: 12px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 4px;
        }

        .slider-group {
            margin-bottom: 16px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.9em;
        }

        .slider-label .name {
            font-weight: 600;
        }

        .slider-label .value {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5568d3;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .strategy-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .giver { background: #22c55e; }
        .matcher { background: #eab308; }
        .taker { background: #ef4444; }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95em;
        }

        .btn-play {
            background: #22c55e;
            color: white;
        }

        .btn-play:hover {
            background: #16a34a;
            transform: translateY(-2px);
        }

        .btn-pause {
            background: #f59e0b;
            color: white;
        }

        .btn-pause:hover {
            background: #d97706;
            transform: translateY(-2px);
        }

        .btn-reset {
            background: #ef4444;
            color: white;
        }

        .btn-reset:hover {
            background: #dc2626;
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .visualization {
            background: white;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
        }

        canvas {
            display: block;
            border-radius: 12px;
        }

        .stats-panel {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #1f2937;
        }

        .population-display {
            margin-top: 16px;
            padding: 12px;
            background: white;
            border-radius: 8px;
        }

        .population-bar {
            display: flex;
            height: 40px;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 8px;
        }

        .pop-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .legend {
            display: flex;
            justify-content: space-around;
            margin-top: 12px;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .payoff-matrix {
            margin-top: 12px;
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9em;
        }

        .payoff-matrix th {
            background: #667eea;
            color: white;
            padding: 8px;
            font-weight: 600;
            text-align: center;
        }

        .payoff-matrix td {
            padding: 8px;
            text-align: center;
            border: 1px solid #e5e7eb;
        }

        .payoff-matrix .label-cell {
            background: #f3f4f6;
            font-weight: 600;
            color: #667eea;
        }

        .payoff-matrix input {
            width: 40px;
            padding: 4px;
            border: 2px solid #667eea;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
            font-weight: 600;
        }

        .payoff-matrix input:focus {
            outline: none;
            border-color: #5568d3;
            background: #f0f4ff;
        }

        .payoff-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .payoff-separator {
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Iterated Prisoner's Dilemma Evolution</h1>
            <p class="subtitle">Watch strategies evolve through natural selection</p>
        </header>

        <div class="main-content">
            <div class="controls-panel">
                <div class="control-section">
                    <h3>Initial Population</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name"><span class="strategy-color giver"></span>Givers (Always Cooperate)</span>
                            <span class="value" id="giver-value">50</span>
                        </div>
                        <input type="range" id="giver-slider" min="0" max="200" value="50">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name"><span class="strategy-color matcher"></span>Matchers (Tit-for-Tat)</span>
                            <span class="value" id="matcher-value">50</span>
                        </div>
                        <input type="range" id="matcher-slider" min="0" max="200" value="50">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name"><span class="strategy-color taker"></span>Takers (Always Defect)</span>
                            <span class="value" id="taker-value">50</span>
                        </div>
                        <input type="range" id="taker-slider" min="0" max="200" value="50">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Simulation Parameters</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name">M: Matches Before Evolution</span>
                            <span class="value" id="m-value">100</span>
                        </div>
                        <input type="range" id="m-slider" min="10" max="1000" value="100" step="10">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name">K: Cull/Spawn Count</span>
                            <span class="value" id="k-value">20</span>
                        </div>
                        <input type="range" id="k-slider" min="1" max="100" value="20">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Payoff Matrix</h3>
                    <div style="font-size: 0.85em; margin-bottom: 8px; color: #6b7280;">
                        Payoffs: (Row Player, Column Player)
                    </div>
                    <table class="payoff-matrix">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Column Player<br>Cooperates</th>
                                <th>Column Player<br>Defects</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="label-cell">Row Player<br>Cooperates</td>
                                <td>
                                    <div class="payoff-cell">
                                        <input type="number" id="cc-row-input" value="3" min="0" max="10">
                                        <span class="payoff-separator">,</span>
                                        <input type="number" id="cc-col-input" value="3" min="0" max="10">
                                    </div>
                                </td>
                                <td>
                                    <div class="payoff-cell">
                                        <input type="number" id="cd-row-input" value="0" min="0" max="10">
                                        <span class="payoff-separator">,</span>
                                        <input type="number" id="cd-col-input" value="5" min="0" max="10">
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td class="label-cell">Row Player<br>Defects</td>
                                <td>
                                    <div class="payoff-cell">
                                        <input type="number" id="dc-row-input" value="5" min="0" max="10">
                                        <span class="payoff-separator">,</span>
                                        <input type="number" id="dc-col-input" value="0" min="0" max="10">
                                    </div>
                                </td>
                                <td>
                                    <div class="payoff-cell">
                                        <input type="number" id="dd-row-input" value="1" min="0" max="10">
                                        <span class="payoff-separator">,</span>
                                        <input type="number" id="dd-col-input" value="1" min="0" max="10">
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <div style="margin-top: 12px; padding: 8px; background: #fff3cd; border-radius: 6px; border: 1px solid #ffc107;">
                        <div style="font-size: 0.85em; font-weight: 600; margin-bottom: 4px; color: #856404;">
                            Rejection Penalty (3 consecutive rejections):
                        </div>
                        <input type="number" id="reject-input" value="-2" min="-10" max="0" style="width: 60px; padding: 6px; border: 2px solid #ffc107; border-radius: 4px; text-align: center; font-weight: 600;">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Memory Behavior</h3>
                    <div style="font-size: 0.85em; margin-bottom: 12px; color: #6b7280;">
                        How should individuals use their memory?
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="memory" value="none" checked>
                            <span>None - Random matching</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="memory" value="affinity">
                            <span>Affinity - Prefer cooperators, avoid betrayers</span>
                        </label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Animation Speed</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name">Speed (ms per match)</span>
                            <span class="value" id="speed-value">5</span>
                        </div>
                        <input type="range" id="speed-slider" min="0" max="7" value="4" step="1">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-play" id="play-btn">Play</button>
                    <button class="btn-pause" id="pause-btn" disabled>Pause</button>
                    <button class="btn-reset" id="reset-btn">Reset</button>
                </div>

                <div class="population-display">
                    <h4>Current Population</h4>
                    <div class="population-bar" id="population-bar"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <span class="strategy-color giver"></span>
                            <span id="giver-count">0</span> Givers
                        </div>
                        <div class="legend-item">
                            <span class="strategy-color matcher"></span>
                            <span id="matcher-count">0</span> Matchers
                        </div>
                        <div class="legend-item">
                            <span class="strategy-color taker"></span>
                            <span id="taker-count">0</span> Takers
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="visualization">
                    <canvas id="canvas" width="1000" height="700"></canvas>
                </div>

                <div class="stats-panel">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Total Matches</div>
                            <div class="stat-value" id="stat-matches">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Individuals</div>
                            <div class="stat-value" id="stat-population">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Evolution Events</div>
                            <div class="stat-value" id="stat-evolutions">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Generation</div>
                            <div class="stat-value" id="stat-generation">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Avg Score (Givers)</div>
                            <div class="stat-value" id="stat-giver-avg">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Avg Score (Matchers)</div>
                            <div class="stat-value" id="stat-matcher-avg">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Avg Score (Takers)</div>
                            <div class="stat-value" id="stat-taker-avg">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const STRATEGY = {
            GIVER: 'giver',
            MATCHER: 'matcher',
            TAKER: 'taker'
        };

        const COLORS = {
            giver: '#22c55e',
            matcher: '#eab308',
            taker: '#ef4444'
        };

        // Individual class
        class Individual {
            constructor(strategy, id, x, y) {
                this.strategy = strategy;
                this.id = id;
                this.x = x;
                this.y = y;
                this.score = 0;
                this.matchCount = 0;
                this.history = new Map(); // Track history with other individuals
                this.wrongedBy = new Set(); // Track who has wronged them (defected when I cooperated)
                this.consecutiveRejections = 0; // Track consecutive match rejections
            }

            decide(opponent) {
                switch (this.strategy) {
                    case STRATEGY.GIVER:
                        return true; // Always cooperate
                    case STRATEGY.TAKER:
                        return false; // Always defect
                    case STRATEGY.MATCHER:
                        // Tit-for-tat: cooperate on first meeting, then copy opponent's last move
                        const lastMove = this.history.get(opponent.id);
                        return lastMove === undefined ? true : lastMove;
                    default:
                        return true;
                }
            }

            recordOpponentMove(opponentId, cooperated) {
                this.history.set(opponentId, cooperated);
            }

            recordWrong(opponentId) {
                this.wrongedBy.add(opponentId);
            }

            isWrongdoer(opponentId) {
                return this.wrongedBy.has(opponentId);
            }

            resetForNewRound() {
                this.matchCount = 0;
            }

            clone(newId) {
                // Create a new individual with the same strategy
                const offspring = new Individual(this.strategy, newId, 0, 0);

                // Inherit last 10 interaction memories (history)
                const historyEntries = Array.from(this.history.entries());
                const last10History = historyEntries.slice(-10);
                for (const [opponentId, cooperated] of last10History) {
                    offspring.history.set(opponentId, cooperated);
                }

                // Inherit last 10 wrongdoers (who wronged the parent)
                const wrongdoersList = Array.from(this.wrongedBy);
                const last10Wrongdoers = wrongdoersList.slice(-10);
                for (const opponentId of last10Wrongdoers) {
                    offspring.wrongedBy.add(opponentId);
                }

                return offspring;
            }
        }

        // Game class
        class Game {
            constructor() {
                this.individuals = [];
                this.nextId = 0;
                this.totalMatches = 0;
                this.generation = 0;
                this.evolutionCount = 0;
                this.running = false;
                this.animations = [];

                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.setupEventListeners();
                this.updateUI();
            }

            setupEventListeners() {
                // Sliders
                document.getElementById('giver-slider').addEventListener('input', (e) => {
                    document.getElementById('giver-value').textContent = e.target.value;
                });
                document.getElementById('matcher-slider').addEventListener('input', (e) => {
                    document.getElementById('matcher-value').textContent = e.target.value;
                });
                document.getElementById('taker-slider').addEventListener('input', (e) => {
                    document.getElementById('taker-value').textContent = e.target.value;
                });
                document.getElementById('m-slider').addEventListener('input', (e) => {
                    document.getElementById('m-value').textContent = e.target.value;
                });
                document.getElementById('k-slider').addEventListener('input', (e) => {
                    document.getElementById('k-value').textContent = e.target.value;
                });

                // Speed slider with discrete values
                const speedMap = [1, 2, 3, 4, 5, 10, 20, 100];
                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    const speed = speedMap[parseInt(e.target.value)];
                    document.getElementById('speed-value').textContent = speed;
                });

                // Buttons
                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('pause-btn').addEventListener('click', () => this.pause());
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
            }

            getAnimationSpeed() {
                const speedMap = [1, 2, 3, 4, 5, 10, 20, 100];
                const sliderValue = parseInt(document.getElementById('speed-slider').value);
                return speedMap[sliderValue];
            }

            play() {
                if (this.individuals.length === 0) {
                    this.initialize();
                }
                this.running = true;
                document.getElementById('play-btn').disabled = true;
                document.getElementById('pause-btn').disabled = false;
                this.gameLoop();
            }

            pause() {
                this.running = false;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
            }

            reset() {
                this.running = false;
                this.individuals = [];
                this.nextId = 0;
                this.totalMatches = 0;
                this.generation = 0;
                this.evolutionCount = 0;
                this.animations = [];

                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;

                this.updateUI();
                this.draw();
            }

            initialize() {
                const giverCount = parseInt(document.getElementById('giver-slider').value);
                const matcherCount = parseInt(document.getElementById('matcher-slider').value);
                const takerCount = parseInt(document.getElementById('taker-slider').value);

                this.individuals = [];
                this.nextId = 0;

                const total = giverCount + matcherCount + takerCount;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 60;

                let currentIndex = 0;

                // Create individuals and position them in a circle
                for (let i = 0; i < giverCount; i++) {
                    const angle = (currentIndex / total) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    this.individuals.push(new Individual(STRATEGY.GIVER, this.nextId++, x, y));
                    currentIndex++;
                }

                for (let i = 0; i < matcherCount; i++) {
                    const angle = (currentIndex / total) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    this.individuals.push(new Individual(STRATEGY.MATCHER, this.nextId++, x, y));
                    currentIndex++;
                }

                for (let i = 0; i < takerCount; i++) {
                    const angle = (currentIndex / total) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    this.individuals.push(new Individual(STRATEGY.TAKER, this.nextId++, x, y));
                    currentIndex++;
                }

                this.updateUI();
                this.draw();
            }

            async gameLoop() {
                while (this.running && this.individuals.length > 1) {
                    await this.runMatch();

                    const speed = this.getAnimationSpeed();
                    await this.sleep(speed);
                }

                if (this.individuals.length <= 1) {
                    this.pause();
                    alert('Simulation ended: only one or fewer individuals remaining!');
                }
            }

            async runMatch() {
                if (this.individuals.length < 2) return;

                // Get memory behavior setting
                const memoryBehavior = document.querySelector('input[name="memory"]:checked').value;
                const rejectPenalty = parseInt(document.getElementById('reject-input').value);

                // Try to find a mutually acceptable match
                let ind1, ind2;
                let matchFound = false;
                let attempts = 0;
                const maxAttempts = this.individuals.length * 2;

                while (!matchFound && attempts < maxAttempts) {
                    attempts++;

                    // Select first individual randomly
                    const available = [...this.individuals];
                    const i1Index = Math.floor(Math.random() * available.length);
                    ind1 = available[i1Index];
                    available.splice(i1Index, 1);

                    // Select second individual (with affinity logic if enabled)
                    let candidate;
                    if (memoryBehavior === 'affinity') {
                        // Separate available partners into cooperators and wrongdoers
                        const cooperators = available.filter(ind => !ind1.wrongedBy.has(ind.id));

                        // 80% chance to pick from cooperators if available, 20% random
                        if (cooperators.length > 0 && Math.random() < 0.8) {
                            const i2Index = Math.floor(Math.random() * cooperators.length);
                            candidate = cooperators[i2Index];
                        } else if (cooperators.length > 0) {
                            const i2Index = Math.floor(Math.random() * cooperators.length);
                            candidate = cooperators[i2Index];
                        } else if (available.length > 0) {
                            const i2Index = Math.floor(Math.random() * available.length);
                            candidate = available[i2Index];
                        }
                    } else {
                        // Random pairing
                        if (available.length > 0) {
                            const i2Index = Math.floor(Math.random() * available.length);
                            candidate = available[i2Index];
                        }
                    }

                    // Check mutual consent (neither has the other as a wrongdoer)
                    if (candidate && memoryBehavior === 'affinity') {
                        const ind1AcceptsInd2 = !ind1.wrongedBy.has(candidate.id);
                        const ind2AcceptsInd1 = !candidate.wrongedBy.has(ind1.id);

                        if (ind1AcceptsInd2 && ind2AcceptsInd1) {
                            ind2 = candidate;
                            matchFound = true;
                        } else {
                            // Match rejected - increment rejection counters
                            if (!ind1AcceptsInd2) {
                                candidate.consecutiveRejections++;
                            }
                            if (!ind2AcceptsInd1) {
                                ind1.consecutiveRejections++;
                            }
                        }
                    } else if (candidate) {
                        // No affinity mode, accept any match
                        ind2 = candidate;
                        matchFound = true;
                    }
                }

                // If no match found after max attempts, pair randomly anyway
                if (!matchFound) {
                    const available = [...this.individuals];
                    const i1Index = Math.floor(Math.random() * available.length);
                    ind1 = available[i1Index];
                    available.splice(i1Index, 1);
                    if (available.length > 0) {
                        const i2Index = Math.floor(Math.random() * available.length);
                        ind2 = available[i2Index];
                    }
                }

                if (!ind2) return; // Safety check

                // Apply rejection penalties if needed (3 consecutive rejections)
                if (ind1.consecutiveRejections >= 3) {
                    ind1.score += rejectPenalty;
                    ind1.consecutiveRejections = 0; // Reset after applying penalty
                }
                if (ind2.consecutiveRejections >= 3) {
                    ind2.score += rejectPenalty;
                    ind2.consecutiveRejections = 0; // Reset after applying penalty
                }

                // Reset rejection counters on successful match
                ind1.consecutiveRejections = 0;
                ind2.consecutiveRejections = 0;

                // Decisions
                const ind1Cooperates = ind1.decide(ind2);
                const ind2Cooperates = ind2.decide(ind1);

                // Update history
                ind1.recordOpponentMove(ind2.id, ind2Cooperates);
                ind2.recordOpponentMove(ind1.id, ind1Cooperates);

                // Track wrongs (cooperated but opponent defected)
                if (ind1Cooperates && !ind2Cooperates) {
                    ind1.recordWrong(ind2.id);
                }
                if (ind2Cooperates && !ind1Cooperates) {
                    ind2.recordWrong(ind1.id);
                }

                // Calculate scores from configurable payoff matrix
                // ind1 is row player, ind2 is column player
                const ccRow = parseInt(document.getElementById('cc-row-input').value);
                const ccCol = parseInt(document.getElementById('cc-col-input').value);
                const cdRow = parseInt(document.getElementById('cd-row-input').value);
                const cdCol = parseInt(document.getElementById('cd-col-input').value);
                const dcRow = parseInt(document.getElementById('dc-row-input').value);
                const dcCol = parseInt(document.getElementById('dc-col-input').value);
                const ddRow = parseInt(document.getElementById('dd-row-input').value);
                const ddCol = parseInt(document.getElementById('dd-col-input').value);

                let ind1Points, ind2Points;
                if (ind1Cooperates && ind2Cooperates) {
                    ind1Points = ccRow;  // Row player cooperates, column cooperates
                    ind2Points = ccCol;
                } else if (ind1Cooperates && !ind2Cooperates) {
                    ind1Points = cdRow;  // Row player cooperates, column defects
                    ind2Points = cdCol;
                } else if (!ind1Cooperates && ind2Cooperates) {
                    ind1Points = dcRow;  // Row player defects, column cooperates
                    ind2Points = dcCol;
                } else {
                    ind1Points = ddRow;  // Both defect
                    ind2Points = ddCol;
                }

                ind1.score += ind1Points;
                ind2.score += ind2Points;
                ind1.matchCount++;
                ind2.matchCount++;

                this.totalMatches++;

                // Add animations
                this.animations.push({
                    x1: ind1.x, y1: ind1.y,
                    x2: ind2.x, y2: ind2.y,
                    points1: ind1Points,
                    points2: ind2Points,
                    time: 0
                });

                // Check for evolution (cull and spawn)
                const M = parseInt(document.getElementById('m-slider').value);
                const allReachedM = this.individuals.every(ind => ind.matchCount >= M);

                if (allReachedM) {
                    this.cullAndSpawn();
                }

                this.updateUI();
                this.draw();
            }

            cullAndSpawn() {
                const K = parseInt(document.getElementById('k-slider').value);

                // Sort by score (best to worst)
                this.individuals.sort((a, b) => b.score - a.score);

                if (this.individuals.length === 0) return;

                // Cull bottom K individuals
                const cullCount = Math.min(K, this.individuals.length - 1); // Keep at least 1
                if (cullCount > 0) {
                    this.individuals = this.individuals.slice(0, -cullCount);
                }

                if (this.individuals.length === 0) return;

                // Spawn K new individuals by randomly cloning survivors
                // Survivors are the ones who made it through culling
                for (let i = 0; i < K; i++) {
                    // Pick a random survivor to clone
                    const parentIndex = Math.floor(Math.random() * this.individuals.length);
                    const parent = this.individuals[parentIndex];

                    // Clone the parent (including last 10 memories)
                    const offspring = parent.clone(this.nextId++);
                    this.individuals.push(offspring);
                }

                // Increment counters
                this.generation++;
                this.evolutionCount++;

                // Reset match counts and reposition
                this.repositionIndividuals();
                this.individuals.forEach(ind => ind.resetForNewRound());
            }

            repositionIndividuals() {
                const total = this.individuals.length;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 60;

                this.individuals.forEach((ind, index) => {
                    const angle = (index / total) * Math.PI * 2;
                    ind.x = centerX + Math.cos(angle) * radius;
                    ind.y = centerY + Math.sin(angle) * radius;
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Update and draw animations
                this.animations = this.animations.filter(anim => {
                    anim.time += 16; // Approximate frame time

                    if (anim.time < 500) {
                        const alpha = 1 - (anim.time / 500);

                        // Draw line
                        this.ctx.save();
                        this.ctx.strokeStyle = `rgba(100, 100, 100, ${alpha * 0.5})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(anim.x1, anim.y1);
                        this.ctx.lineTo(anim.x2, anim.y2);
                        this.ctx.stroke();
                        this.ctx.restore();

                        // Draw points
                        this.ctx.save();
                        this.ctx.fillStyle = `rgba(0, 150, 0, ${alpha})`;
                        this.ctx.font = 'bold 16px sans-serif';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`+${anim.points1}`, anim.x1, anim.y1 - 20 - anim.time / 10);
                        this.ctx.fillText(`+${anim.points2}`, anim.x2, anim.y2 - 20 - anim.time / 10);
                        this.ctx.restore();

                        return true;
                    }
                    return false;
                });

                // Draw individuals
                this.individuals.forEach(ind => {
                    this.ctx.save();
                    this.ctx.fillStyle = COLORS[ind.strategy];
                    this.ctx.beginPath();
                    this.ctx.arc(ind.x, ind.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                    this.ctx.restore();
                });
            }

            updateUI() {
                const givers = this.individuals.filter(i => i.strategy === STRATEGY.GIVER);
                const matchers = this.individuals.filter(i => i.strategy === STRATEGY.MATCHER);
                const takers = this.individuals.filter(i => i.strategy === STRATEGY.TAKER);
                const total = this.individuals.length;

                // Update counts
                document.getElementById('giver-count').textContent = givers.length;
                document.getElementById('matcher-count').textContent = matchers.length;
                document.getElementById('taker-count').textContent = takers.length;

                // Update population bar
                const giverPercent = total > 0 ? (givers.length / total) * 100 : 0;
                const matcherPercent = total > 0 ? (matchers.length / total) * 100 : 0;
                const takerPercent = total > 0 ? (takers.length / total) * 100 : 0;

                const popBar = document.getElementById('population-bar');
                popBar.innerHTML = '';

                if (giverPercent > 0) {
                    const div = document.createElement('div');
                    div.className = 'pop-segment giver';
                    div.style.width = giverPercent + '%';
                    div.textContent = giverPercent >= 10 ? `${Math.round(giverPercent)}%` : '';
                    popBar.appendChild(div);
                }

                if (matcherPercent > 0) {
                    const div = document.createElement('div');
                    div.className = 'pop-segment matcher';
                    div.style.width = matcherPercent + '%';
                    div.textContent = matcherPercent >= 10 ? `${Math.round(matcherPercent)}%` : '';
                    popBar.appendChild(div);
                }

                if (takerPercent > 0) {
                    const div = document.createElement('div');
                    div.className = 'pop-segment taker';
                    div.style.width = takerPercent + '%';
                    div.textContent = takerPercent >= 10 ? `${Math.round(takerPercent)}%` : '';
                    popBar.appendChild(div);
                }

                // Update statistics
                document.getElementById('stat-matches').textContent = this.totalMatches;
                document.getElementById('stat-population').textContent = total;
                document.getElementById('stat-evolutions').textContent = this.evolutionCount;
                document.getElementById('stat-generation').textContent = this.generation;

                const giverAvg = givers.length > 0
                    ? Math.round(givers.reduce((sum, ind) => sum + ind.score, 0) / givers.length)
                    : 0;
                const matcherAvg = matchers.length > 0
                    ? Math.round(matchers.reduce((sum, ind) => sum + ind.score, 0) / matchers.length)
                    : 0;
                const takerAvg = takers.length > 0
                    ? Math.round(takers.reduce((sum, ind) => sum + ind.score, 0) / takers.length)
                    : 0;

                document.getElementById('stat-giver-avg').textContent = giverAvg;
                document.getElementById('stat-matcher-avg').textContent = matcherAvg;
                document.getElementById('stat-taker-avg').textContent = takerAvg;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>
